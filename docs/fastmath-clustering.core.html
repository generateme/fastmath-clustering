<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>fastmath-clustering.core documentation</title><script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Fastmath-clustering</span> <span class="project-version">1.0.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fastmath-clustering</span></div></div></li><li class="depth-2 branch current"><a href="fastmath-clustering.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="fastmath-clustering.distance.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>distance</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="fastmath-clustering.core.html#var-clarans"><div class="inner"><span>clarans</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-clustering-methods-list"><div class="inner"><span>clustering-methods-list</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-dbscan"><div class="inner"><span>dbscan</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-denclue"><div class="inner"><span>denclue</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-deterministic-annealing"><div class="inner"><span>deterministic-annealing</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-g-means"><div class="inner"><span>g-means</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-k-means"><div class="inner"><span>k-means</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-lloyd"><div class="inner"><span>lloyd</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-mec"><div class="inner"><span>mec</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-outlier-id"><div class="inner"><span>outlier-id</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-predict"><div class="inner"><span>predict</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-regroup"><div class="inner"><span>regroup</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-spectral"><div class="inner"><span>spectral</span></div></a></li><li class="depth-1"><a href="fastmath-clustering.core.html#var-x-means"><div class="inner"><span>x-means</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">fastmath-clustering.core</h1><div class="doc"><div class="markdown"><p>Clustering.</p>
<p>Various clustering algrorithms backed by SMILE library.</p>
<p>Only partition clustering is implemented.</p>
<h3><a href="#input-data" id="input-data"></a>Input data</h3>
<p>Itâ€™s always sequence of n-sized samples as sequences.</p>
<p>For example, 2d samples <code>[[1 2] [2 2] [3 3] ...]</code></p>
<p>For 1d data you can pass sequence of numbers of sequence of 1d seqs of numbers</p>
<pre><code class="language-clojure">[1 2 3]
;; or
[[1] [2] [3]]
</code></pre>
<h3><a href="#distances" id="distances"></a>Distances</h3>
<p>Some of the methods use distance functions, use <a href="fastmath-clustering.distance.html">fastmath-clustering.distance</a> namespace to create or use one.</p>
<h3><a href="#output" id="output"></a>Output</h3>
<p>Every function returns record which contains:</p>
<ul>
<li><code>:type</code> - name of the method used</li>
<li><code>:data</code> - input data</li>
<li><code>:clustering</code> - sequence of cluster ids</li>
<li><code>:sizes</code> - sizes of clusters</li>
<li><code>:clusters</code> - number of clusters</li>
<li><code>:predict</code> - predicting function (see below), qualify additional sample</li>
<li><code>:representatives</code> - list of centroids or averages</li>
<li><code>:info</code> - additional statistics for your samples (like distortion)</li>
<li><code>:obj</code> - SMILE object</li>
</ul>
<p>Cluster id is a integer ranging from 0 to the number of clusters minus 1. Some methods mark outliers with <a href="fastmath-clustering.core.html#var-outlier-id">outlier-id</a>.</p>
<p>Record acts as function and can qualify additonal sample by calling <code>:predict</code> function (or just call <a href="fastmath-clustering.core.html#var-predict">predict</a>), for example (<code>data</code> is sequence of 3d samples):</p>
<pre><code class="language-clojure">(let [cl (k-means data 10)] (cl [0 1 2]))
</code></pre>
<p>See <a href="fastmath-clustering.core.html#var-k-means">k-means</a></p>
<h4><a href="#regrouping" id="regrouping"></a>Regrouping</h4>
<p>Clustering record can be regroupped to the list of individual clusters. Call <a href="fastmath-clustering.core.html#var-regroup">regroup</a> and get list of maps with following structure:</p>
<ul>
<li><code>:key</code> - cluster id or <code>:outliers</code></li>
<li><code>:data</code> - samples which belong to the cluster</li>
<li><code>:representative</code> - centroid or average vector if the former is not available</li>
<li><code>:size</code> - size of cluster</li>
</ul>
</div><div class="markdown"><h4>Categories</h4><ul></ul><p>Other vars: <a>-&gt;ClusteringResult</a> <a href="fastmath-clustering.core.html#var-clarans">clarans</a> <a href="fastmath-clustering.core.html#var-clustering-methods-list">clustering-methods-list</a> <a href="fastmath-clustering.core.html#var-dbscan">dbscan</a> <a href="fastmath-clustering.core.html#var-denclue">denclue</a> <a href="fastmath-clustering.core.html#var-deterministic-annealing">deterministic-annealing</a> <a href="fastmath-clustering.core.html#var-g-means">g-means</a> <a href="fastmath-clustering.core.html#var-k-means">k-means</a> <a href="fastmath-clustering.core.html#var-lloyd">lloyd</a> <a>map-&gt;ClusteringResult</a> <a href="fastmath-clustering.core.html#var-mec">mec</a> <a href="fastmath-clustering.core.html#var-predict">predict</a> <a href="fastmath-clustering.core.html#var-regroup">regroup</a> <a href="fastmath-clustering.core.html#var-spectral">spectral</a> <a href="fastmath-clustering.core.html#var-x-means">x-means</a></p></div><div class="markdown"><h4>Constants</h4><ul><li><a href="fastmath-clustering.core.html#var-outlier-id">outlier-id</a> = <code>2147483647</code></li></ul></div></div><div class="public anchor" id="var-clarans"><h3>clarans</h3><div class="usage"><code>(clarans data clusters)</code><code>(clarans data dist clusters)</code><code>(clarans data dist clusters max-neighbor)</code></div><div class="doc"><div class="markdown"><p>Clustering Large Applications based upon RANdomized Search algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>dist (optional) - distance method, default <code>euclidean</code></li>
<li>clusters - number of clusters</li>
<li>max-neighbor (optional) - maximum number of neighbors checked during random search</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/CLARANS.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p>
</blockquote><pre><code class="hljs clojure">(dissoc (clarans (repeatedly
                  1000
                  (fn* [] (randval 0.1 (irand -10 10) (irand 100 150))))
                 d/chebyshev
                 2)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 2,
;;=&gt;  :info {:distortion 11663.0},
;;=&gt;  :representatives ((126.0) (0.0)),
;;=&gt;  :sizes (892 108 0),
;;=&gt;  :type :clarans}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L241">view source</a></div></div><div class="public anchor" id="var-clustering-methods-list"><h3>clustering-methods-list</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>List of clustering methods.</p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>List of methods</p>
</blockquote><pre><code class="hljs clojure">clustering-methods-list
;;=&gt; (:spectral :dbscan
;;=&gt;            :k-means :mec
;;=&gt;            :clarans :g-means
;;=&gt;            :lloyd :x-means
;;=&gt;            :deterministic-annealing :denclue)</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L146">view source</a></div></div><div class="public anchor" id="var-dbscan"><h3>dbscan</h3><div class="usage"><code>(dbscan data min-pts radius)</code><code>(dbscan data dist min-pts radius)</code></div><div class="doc"><div class="markdown"><p>Density-Based Spatial Clustering of Applications with Noise algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>dist (optional) - distance method, default <code>euclidean</code></li>
<li>min-pts - minimum number of neighbors</li>
<li>radius - the neighborhood radius</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/DBSCAN.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>3d vectors</p>
</blockquote><pre><code class="hljs clojure">(dissoc (dbscan (repeatedly
                 5000
                 (fn* []
                   (vector (randval 0.1 (irand -10 10) (irand 100 150))
                           (randval (irand -10 10) (irand 100 150))
                           (randval (irand -10 10) (irand 100 150)))))
                10
                20)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 8,
;;=&gt;  :info {},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (1146 1135 1144 134 128 1104 105 104 0),
;;=&gt;  :type :dbscan}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L272">view source</a></div></div><div class="public anchor" id="var-denclue"><h3>denclue</h3><div class="usage"><code>(denclue data sigma m)</code><code>(denclue data sigma m tolerance)</code><code>(denclue data sigma m tolerance min-pts)</code></div><div class="doc"><div class="markdown"><p>DENsity CLUstering algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>sigma - gaussian kernel parameter</li>
<li>m - number of selected samples, much smaller than number of all samples</li>
<li>tolerance (optional) - tolerance of hill-climbing procedure</li>
<li>min-pts (optional) - minimum number of neighbors for a core attractor</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/DENCLUE.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, uniform distribution.</p>
</blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (denclue (repeatedly 100 (fn* [] (randval (drand) (drand 5 6)))) 1 10))
;;=&gt; [2 (56 44 0) nil]
(map
 (fn [m] (dissoc m :data))
 (regroup
  (denclue (repeatedly 1000 (fn* [] (randval 0.1 (drand) (drand 5 6))))
           1
           10)))
;;=&gt; ({:key 0, :representative 5.505301647597941, :size 904}
;;=&gt;  {:key 1, :representative 0.5564660309322467, :size 96})</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L256">view source</a></div></div><div class="public anchor" id="var-deterministic-annealing"><h3>deterministic-annealing</h3><div class="usage"><code>(deterministic-annealing data max-clusters)</code><code>(deterministic-annealing data max-clusters alpha)</code><code>(deterministic-annealing data max-clusters alpha max-iter)</code><code>(deterministic-annealing data max-clusters alpha max-iter tolerance)</code><code>(deterministic-annealing data max-clusters alpha max-iter tolerance split-tolerance)</code></div><div class="doc"><div class="markdown"><p>Deterministic Annealing algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>max-clusters - number of clusters</li>
<li>alpha (optional) - temperature decreasing factor (valued from 0 to 1)</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of convergence test</li>
<li>split-tolerance (optional) - tolerance to split a cluster</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/DeterministicAnnealing.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p>
</blockquote><pre><code class="hljs clojure">(map (fn [m] (dissoc m :data))
     (-&gt; (repeatedly 1000
                     (fn* []
                       (vector (randval (grand) (grand 5 1.0))
                               (randval (grand) (grand 5 1.0)))))
         (deterministic-annealing 4 0.5)
         (regroup)))
;;=&gt; ({:key 0,
;;=&gt;   :representative (-0.058611378919933725 -0.013552096996870055),
;;=&gt;   :size 281}
;;=&gt;  {:key 2,
;;=&gt;   :representative (4.940048941144213 0.02248054975189403),
;;=&gt;   :size 232}
;;=&gt;  {:key 3,
;;=&gt;   :representative (4.92413297904191 4.976792268230151),
;;=&gt;   :size 252}
;;=&gt;  {:key 1,
;;=&gt;   :representative (0.02674989928953795 5.039325640322584),
;;=&gt;   :size 235})</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L219">view source</a></div></div><div class="public anchor" id="var-g-means"><h3>g-means</h3><div class="usage"><code>(g-means data clusters)</code><code>(g-means data clusters max-iter)</code><code>(g-means data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>G-Means</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>clusters - number of clusters</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/GMeans.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, uniform distribution.</p>
</blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (g-means (repeatedly 100 (fn* [] (randval (drand) (drand 5 6)))) 4))
;;=&gt; [2 (52 48 0) ((5.499012776162546) (0.44981210779716996))]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L189">view source</a></div></div><div class="public anchor" id="var-k-means"><h3>k-means</h3><div class="usage"><code>(k-means data clusters)</code><code>(k-means data clusters max-iter)</code><code>(k-means data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>K-Means++ algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>clusters - number of clusters</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/KMeans.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Usage</p>
</blockquote><pre><code class="hljs clojure">(k-means [1 2 3 -1 -1 2 -1 11 111] 4)
;;=&gt; #fastmath_clustering.core.ClusteringResult
;;=&gt;  {:clustering (3 3 3 0 0 3 0 2 1),
;;=&gt;   :clusters 4,
;;=&gt;   :data [1 2 3 -1 -1 2 -1 11 111],
;;=&gt;   :info {:distortion 2.0000000000000004},
;;=&gt;   :obj
;;=&gt;   #object[smile.clustering.KMeans 0x1fd5eb93 "Cluster distortion: 2.00000\nCluster size of 9 data points:\nCluster    1      3 (33.3%)\nCluster    2      1 (11.1%)\nCluster    3      1 (11.1%)\nCluster    4      4 (44.4%)\n"],
;;=&gt;   :predict #<fn@1565afbf fastmath_clustering.core="" _means[fn]="">,
;;=&gt;   :representatives ((-1.0) (111.0) (11.0) (2.0)),
;;=&gt;   :sizes (3 1 1 4 0),
;;=&gt;   :type :k-means}</fn@1565afbf></code></pre></div><div><blockquote><p>Clusters group into separate maps.</p>
</blockquote><pre><code class="hljs clojure">(regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 4))
;;=&gt; ({:data (1 2 3 2), :key 3, :representative (2.0), :size 4}
;;=&gt;  {:data (-1 -1 -1), :key 0, :representative (-1.0), :size 3}
;;=&gt;  {:data (11), :key 2, :representative (11.0), :size 1}
;;=&gt;  {:data (111), :key 1, :representative (111.0), :size 1})</code></pre></div><div><blockquote><p>Use as predictor</p>
</blockquote><pre><code class="hljs clojure">(let [cl (k-means [1 2 3 -1 -1 2 -1 11 111] 4)]
  [(cl -1) (cl 10) (cl 100) (cl 1) (cl -1000) (cl 1000)])
;;=&gt; [3 2 1 0 3 1]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L159">view source</a></div></div><div class="public anchor" id="var-lloyd"><h3>lloyd</h3><div class="usage"><code>(lloyd data clusters)</code><code>(lloyd data clusters max-iter)</code><code>(lloyd data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>K-Means algorithm, lloyd.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>clusters - number of clusters</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/KMeans.html">SMILE doc</a></p>
</div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L174">view source</a></div></div><div class="public anchor" id="var-mec"><h3>mec</h3><div class="usage"><code>(mec data max-clusters radius)</code><code>(mec data dist max-clusters radius)</code></div><div class="doc"><div class="markdown"><p>Nonparametric Minimum Conditional Entropy Clustering algorithm.</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>dist (optional) - distance method, default <code>:euclidean</code></li>
<li>max-clusters - maximum number of clusters</li>
<li>radius - the neighborhood radius</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/MEC.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>2d vectors</p>
</blockquote><pre><code class="hljs clojure">(dissoc (mec (repeatedly 5000
                         (fn* []
                           (vector
                            (randval 0.1 (irand -10 10) (irand 100 150))
                            (randval (irand -10 10) (irand 100 150)))))
             d/manhattan
             8
             20)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 4,
;;=&gt;  :info {:entropy 0.0},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (236 2223 231 2310 0),
;;=&gt;  :type :mec}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L286">view source</a></div></div><div class="public anchor" id="var-outlier-id"><h3>outlier-id</h3><h4 class="dynamic">const</h4><div class="usage"></div><div><div class="markdown"><code class="hljs clojure">;;=&gt; 2147483647</code></div></div><div class="doc"><div class="markdown"><p>Id of the cluster which contain outliers.</p>
</div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L63">view source</a></div></div><div class="public anchor" id="var-predict"><h3>predict</h3><div class="usage"><code>(predict cluster in)</code></div><div class="doc"><div class="markdown"><p>Predict cluster for given vector</p>
</div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L71">view source</a></div></div><div class="public anchor" id="var-regroup"><h3>regroup</h3><div class="usage"><code>(regroup {:keys [clustering data representatives sizes]})</code></div><div class="doc"><div class="markdown"><p>Transform clustering result into list of clusters as separate maps.</p>
<p>Every map contain:</p>
<ul>
<li><code>:key</code> - cluster id or <code>:outliers</code></li>
<li><code>:data</code> - samples which belong to the cluster</li>
<li><code>:representative</code> - centroid/medoid or average vector if the former is not available</li>
<li><code>:size</code> - size of cluster</li>
</ul>
<p>Representative is always a n-dimensional sequence even if input is a list of numbers.</p>
<p>Empty clusters are skipped.</p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Result of clustering with regrouping</p>
</blockquote><pre><code class="hljs clojure">(k-means [1 2 3 -1 -1 2 -1 11 111] 7)
;;=&gt; #fastmath_clustering.core.ClusteringResult
;;=&gt;  {:clustering (5 3 4 0 0 3 0 2 1),
;;=&gt;   :clusters 7,
;;=&gt;   :data [1 2 3 -1 -1 2 -1 11 111],
;;=&gt;   :info {:distortion 0.0},
;;=&gt;   :obj
;;=&gt;   #object[smile.clustering.KMeans 0x1f15bbb "Cluster distortion: 0.00000\nCluster size of 9 data points:\nCluster    1      3 (33.3%)\nCluster    2      1 (11.1%)\nCluster    3      1 (11.1%)\nCluster    4      2 (22.2%)\nCluster    5      1 (11.1%)\nCluster    6      1 (11.1%)\nCluster    7      0 ( 0.0%)\n"],
;;=&gt;   :predict #<fn@404dabf3 fastmath_clustering.core="" _means[fn]="">,
;;=&gt;   :representatives ((-1.0) (111.0) (11.0) (2.0) (3.0) (1.0) (##NaN)),
;;=&gt;   :sizes (3 1 1 2 1 1 0 0),
;;=&gt;   :type :k-means}
(regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 7))
;;=&gt; ({:data (1), :key 5, :representative (1.0), :size 1}
;;=&gt;  {:data (2 2), :key 2, :representative (2.0), :size 2}
;;=&gt;  {:data (3), :key 4, :representative (3.0), :size 1}
;;=&gt;  {:data (-1 -1 -1), :key 3, :representative (-1.0), :size 3}
;;=&gt;  {:data (11), :key 0, :representative (11.0), :size 1}
;;=&gt;  {:data (111), :key 1, :representative (111.0), :size 1})
(count (regroup (k-means [1 2 3 -1 -1 2 -1 11 111] 7)))
;;=&gt; 6</fn@404dabf3></code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L87">view source</a></div></div><div class="public anchor" id="var-spectral"><h3>spectral</h3><div class="usage"><code>(spectral data clusters sigma)</code><code>(spectral data clusters sigma max-iters tolerance)</code><code>(spectral data clusters samples sigma)</code><code>(spectral data clusters samples sigma max-iters tolerance)</code></div><div class="doc"><div class="markdown"><p>Spectral clustering</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>clusters - number of clusters</li>
<li>samples (optional) - number of random samples for Nystrom approximation</li>
<li>sigma - width parameter for Gaussian kernel</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of k-means convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/SpectralClustering.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>2d vectors</p>
</blockquote><pre><code class="hljs clojure">(dissoc (spectral
         (repeatedly 500
                     (fn* []
                       (vector
                        (randval 0.1 (irand -10 10) (irand 100 150))
                        (randval (irand -10 10) (irand 100 150)))))
         4
         1)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 4,
;;=&gt;  :info {:distortion 19.149259019097173},
;;=&gt;  :representatives nil,
;;=&gt;  :sizes (263 185 32 20 0),
;;=&gt;  :type :spectral}</code></pre></div><div><blockquote><p>2d vectors</p>
</blockquote><pre><code class="hljs clojure">(dissoc (lloyd (repeatedly
                500
                (fn* []
                  (vector (randval 0.1 (irand -10 10) (irand 100 150))
                          (randval (irand -10 10) (irand 100 150)))))
               4
               1)
        :data :clustering
        :obj :predict)
;;=&gt; {:clusters 4,
;;=&gt;  :info {:distortion 340165.77580992214},
;;=&gt;  :representatives ((79.75 -1.1704545454545454)
;;=&gt;                    (0.10344827586206896 123.89655172413794)
;;=&gt;                    (124.16589861751152 123.33640552995392)
;;=&gt;                    (130.3734939759036 -0.536144578313253)),
;;=&gt;  :sizes (88 29 217 166 0),
;;=&gt;  :type :lloyd}</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L300">view source</a></div></div><div class="public anchor" id="var-x-means"><h3>x-means</h3><div class="usage"><code>(x-means data clusters)</code><code>(x-means data clusters max-iter)</code><code>(x-means data clusters max-iter tolerance)</code></div><div class="doc"><div class="markdown"><p>X-Means</p>
<p>Input:</p>
<ul>
<li>data - sequence of samples</li>
<li>clusters - number of clusters</li>
<li>max-iter (optional) - maximum number of iterations</li>
<li>tolerance (optional) - tolerance of convergence test</li>
</ul>
<p>See more in <a href="https://haifengl.github.io/api/java/smile/clustering/XMeans.html">SMILE doc</a></p>
</div></div><div class="markdown"><h4>Examples</h4><div><blockquote><p>Expect 2 clusters, gaussian distribution.</p>
</blockquote><pre><code class="hljs clojure">((juxt :clusters :sizes :representatives)
 (x-means (repeatedly 10000 (fn* [] (randval (grand) (grand 5 1.0))))
          4))
;;=&gt; [2 (5011 4989 0) ((5.008429199918388) (-0.004122666084406418))]</code></pre></div></div><div class="src-link"><a href="https://github.com/generateme/fastmath-clustering/blob/master/src/fastmath_clustering/core.clj#L204">view source</a></div></div></div></body></html>